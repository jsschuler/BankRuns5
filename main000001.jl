################################################################################
#              Replacement Bank Run Model                                      #
#               (networked)                                                    #
#               August 2023                                                    #
#               John S. Schuler                                                #
#               Main Control Code                                              #
################################################################################
using Folds
using Distributions
using Random
using Distributed
using CSV
using DataFrames
using Graphs
using StatsBase
using JLD2
using Dates
# This code loads a data frame generated by the parameter sweep code
# it also loads a progresss log so it can drop already run model versions.
# each parameterization (INCLUDING THE SEED) defines a model and is thus the
# model key
println("Threads")
println(Threads.nthreads())

dataDir="BankRunData"




# load control file
#ctrlFile=ARGS[1]
ctrlFile="runCtrl_20230831191053.jld2"
#println(ctrlFile)
ctrlFrame=load_object(ctrlFile)
#println(ctrlFrame[1:10,:])
# load only incomplete models
ctrlWorking=ctrlFrame[ctrlFrame[:,"complete"].==false,:]

# find the first row of the control df that is not complete
argVec=ctrlWorking[1,:]

# parse the argVec for the model parameters
# key to identify the model
key=argVec[4]
# set a seed to render the results recoverable
Random.seed!(argVec[2])
# how many agents?
agtCnt=argVec[5]
# what is the exogenous probability of withdrawal?

#println("exogP")
#println(argVec[14])
exogP=argVec[14]
exogP::Float64
# We consider withdrawal a "failure" a withdrawal.
# we set the geometric parameter such that the
# expected number of failures is equal to the exogP
# potion of the population.
# NOTE THIS NOT THE SAME AS THE STANDARD Parameter
expWithdrawal=exogP*agtCnt
expWithdrawal::Float64
#println("Expected Withdrawals")
#println(expWithdrawal)
exogDist=Geometric(1/(expWithdrawal+1))
# how many rounds to agents simulate?
depth=argVec[15]
depth::Int64
# we need an agent ticker
agtTicker=0
agtTicker::Int64
# also, we need a parameter for the number of periods over which agents observe agtWithdrawals
withdrawPeriods=argVec[6]
withdrawPeriods::Int64

reserveRatio=argVec[7]
reserveRatio::Float64
# now, we need a range of subjective probabilities of getting nothing
loP=argVec[8]
loP::Float64
hiP=argVec[9]
hiP::Float64
probGenR=Uniform(loP,hiP)
# and we need the distribution of agent deposits
# we will use two parametric families (Gamma (discretized))
# and Levy, also discretized
distribution=argVec[16]
distributionParams=[argVec[17],argVec[18]]
distribution::String
#println(distribution)
if distribution=="Gamma"
    dist=Gamma(distributionParams[1],distributionParams[2])
else
    rawDist=Levy(distributionParams[1],distributionParams[2])
    # we want the to allow values no greater than 10000 times the first percentile 
    base::Float64=quantile(rawDist,.01)
    top::Float64=10000*base
    dist=truncated(rawDist,0,top)
end

# now from the distribution, determine the cut off for deposit depositInsurance
# if the deposit insurance is infinite, we set it to the largest agent deposit 


depositInsurance::UInt64=round(UInt64,quantile(dist,argVec[20]))
failurePay::UInt64=UInt64(0)


include("objects.jl")

# we need to record any agent who breaks the bank
bankBreaker::Union{Nothing,Agent}=nothing
# and to record how much the bank was able to pay out 
failurePay::UInt64=0


include("functions3.jl")



# also, what type of Graph is used?

graphType=argVec[11]
graphParams=[argVec[12],argVec[13]]

neighborDepth=argVec[14]
# and a list of all agents
agtList=Agent[]
# generate agents
for idx in 1:agtCnt
    agtGen()
end

# now, the agents need to decide if they will bank 
empiricalProb=Float64[]
bestBoolList::Array{Array{Bool}}=Array{Bool}[]
minDelta::Float64=1.0
theorProbs=collect(0.05:0.05:1)

for bankProb in theorProbs
    bankingCount::Int64=0
    tmpBool=Bool[]
    for agt in agtList
        println("Simulating")
        wdPct=initSimulate(agt,bankProb)
        if wdPct < agt.p 
            bankingCount=bankingCount+1
            push!(tmpBool,true)
        else
            push!(tmpBool,false)
        end
    end
    push!(bestBoolList,tmpBool)
    currProb=bankingCount/length(agtList)    
    push!(empiricalProb,currProb)
end

# now compare the empirical probability to the probability the agents assume 

pDelta=abs.(empiricalProb.-theorProbs)
minDelta=1.0
minK=0
for k in 1:length(pDelta)
    if pDelta[k] < minDelta
        minDelta=pDelta[k]
        minK=k
    end
end

participants=bestBoolList[minK]

bankingAgents=Agent[]
for k in 1:length(participants)
    if participants[k]
        push!(bankingAgents,agtList[k])
    end
end

# now replace agent list with only those banking
agtList=bankingAgents

# now record agents 
postDecisionTicker::Int64=0
for agt in agtList
    postDecisionTicker=postDecisionTicker+1
    agt.idx=postDecisionTicker
    agtWrite(agt)
end


theGraph=graphGen()
graphWrite()
# generate bank
theBank=bankGen()



# now set second seed
Random.seed!(argVec[3])

modWrite(false)
#println("Model Begins")
#println(theBank.vault)
# step 1: exogenous withdrawals
schedule=exogWithdraw()
notFail=true
notFail::Bool
# now. begin the model
for t in 1:withdrawPeriods
    # exogenously withdraw agents
    println("Exog Withdraw")
    println(schedule[t])
    for wAgt in schedule[t]
        #println(wAgt.idx)
        withdraw(wAgt,true,t,0)
        global notFail
        notFail=bankrupt()
        println(theBank.vault)
    end
    global notFail
    if !notFail
        println("Bank Failure?")
        println(!notFail)
        # give an instruction to avoid error
        zzz=5
        break
    end
    # now, let the agents react in a random order
    halt=true
    halt::Bool
    tCnt=0
    tCnt::Int64
    while halt
        tCnt=tCnt+1
        stopCond=true
        stopCond::Bool
        # who is still banking?
        stillIn=bankedAgts()
        #println(stillIn)
        for stAgt in stillIn
            decide=decision(stAgt,t,tCnt)
            #println("Decision")
            #println(decide)
            #println(stAgt.p)
            if decide
                global notFail
                notFail=withdraw(stAgt,false,t,tCnt)
                stopCond=false
                #println(t)
                #println(tCnt)
                #println("withdrawal")

            end
            global notFail
            if !notFail
                break
            end
        end
        global notFail
        if stopCond | !notFail
            break
        end
    end
#println("Bank Failure?")
#println(!notFail)
end

# now, if the bank has failed, calculate deposit insurance payouts 
if !notFail



modWrite(true)
