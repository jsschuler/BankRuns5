################################################################################
#              Replacement Bank Run Model                                      #
#               (networked)                                                    #
#               June 2022                                                      #
#               John S. Schuler                                                #
#               Main Control Code                                              #
################################################################################
using Folds
using Distributions
using Random
using Distributed
using CSV
using DataFrames
using Graphs
using StatsBase
using JLD2
using Dates
# This code loads a data frame generated by the parameter sweep code
# it also loads a progresss log so it can drop already run model versions.
# each parameterization (INCLUDING THE SEED) defines a model and is thus the
# model key
#println("Threads")
#println(Threads.nthreads())

dataDir="Data1"
include("objects.jl")
include("functions.jl")
# load control file
ctrlFile=ARGS[1]
#println(ctrlFile)
ctrlFrame=load_object(ctrlFile)
#println(ctrlFrame[1:10,:])
# load only incomplete models
ctrlWorking=ctrlFrame[ctrlFrame[:,"complete"].==false,:]

# find the first row of the control df that is not complete
argVec=ctrlWorking[1,:]



# parse the argVec for the model parameters
# key to identify the model
key=argVec[4]
# set a seed to render the results recoverable
Random.seed!(argVec[2])
# how many agents?
agtCnt=argVec[5]
# what is the exogenous probability of withdrawal?

#println("exogP")
#println(argVec[14])
exogP=argVec[14]
exogP::Float64
# We consider withdrawal a "failure" a withdrawal.
# we set the geometric parameter such that the
# expected number of failures is equal to the exogP
# potion of the population.
# NOTE THIS NOT THE SAME AS THE STANDARD Parameter
expWithdrawal=exogP*agtCnt
expWithdrawal::Float64
#println("Expected Withdrawals")
#println(expWithdrawal)
exogDist=Geometric(1/(expWithdrawal+1))
# how many rounds to agents simulate?
depth=argVec[15]
depth::Int64
# we need an agent ticker
agtTicker=0
agtTicker::Int64
# also, we need a parameter for the number of periods over which agents observe agtWithdrawals
withdrawPeriods=argVec[6]
withdrawPeriods::Int64

reserveRatio=argVec[7]
reserveRatio::Float64
# now, we need a range of subjective probabilities of getting nothing
loP=argVec[8]
loP::Float64
hiP=argVec[9]
hiP::Float64
probGenR=Uniform(loP,hiP)
# and we need the distribution of agent deposits
# we will use two parametric families (Gamma (discretized))
# and Levy, also discretized
distribution=argVec[16]
distributionParams=[argVec[17],argVec[18]]
distribution::String
#println(distribution)
if distribution=="Gamma"
    dist=Gamma(distributionParams[1],distributionParams[2])
else
    rawDist=Levy(distributionParams[1],distributionParams[2])
    # we want the to allow values no greater than 10000 times the first percentile 
    base::Float64=quantile(rawDist,.01)
    top::Float64=10000*base
    dist=truncated(rawDist,0,top)


end

# also, what type of Graph is used?

graphType=argVec[11]
graphParams=[argVec[12],argVec[13]]

# and a list of all agents
agtList=Agent[]
# generate agents
for idx in 1:agtCnt
    agtGen()
end

# now, the agents need to decide if they will bank 
empiricalProb=Float64[]
bestBoolList::Array{Bool}=repeat([false],length(agtList))
minDelta::Float64=1.0
for bankProb in 0.05:0.05:1
    bankingCount::Int64=0
    tmpBool=Bool[]
    for agt in agtList
        println("Simulating")
        wdPct=initSimulate(agt,bankProb)
        if wdPct < agt.p 
            bankingCount=bankingCount+1
            push!(tmpBool,true)
        else
            push!(tmpBool,false)
        end
    end
    currProb=bankingCount/length(agtList)    
    push!(empiricalProb,currProb)
    if abs(currProb-bankProb) < minDelta
        bestBoolList=tmpBool
    end
end
exit()
for i in 1:length(bestBoolList)
    if !bestBoolList[i]
        deleteat!(agtList,i)
    end
end

# now record agents 
postDecisionTicker::Int64=0
for agt in agtList
    postDecisionTicker=postDecisionTicker+1
    agt.idx=postDecisionTicker
    agtWrite(agt)
end


theGraph=graphGen()
graphWrite()
# generate bank
theBank=bankGen()

# now set second seed
Random.seed!(argVec[3])

modWrite(false)
#println("Model Begins")
#println(theBank.vault)
# step 1: exogenous withdrawals
schedule=exogWithdraw()
notFail=true
notFail::Bool
# now. begin the model
for t in 1:withdrawPeriods
    # exogenously withdraw agents
    #println("Exog Withdraw")
    #println(schedule[t])
    for wAgt in schedule[t]
        #println(wAgt.idx)
        global notFail
        notFail=withdraw(wAgt,true,t,0)
        #println(theBank.vault)
    end
    global notFail
    if !notFail
        #println("Bank Failure?")
        #println(!notFail)
        # give an instruction to avoid error
        zzz=5
        break
    end
    # now, let the agents react in a random order
    halt=true
    halt::Bool
    tCnt=0
    tCnt::Int64
    while halt
        tCnt=tCnt+1
        stopCond=true
        stopCond::Bool
        # who is still banking?
        stillIn=bankedAgts()
        #println(stillIn)
        for stAgt in stillIn
            decide=decision(stAgt,t,tCnt)
            #println("Decision")
            #println(decide)
            #println(stAgt.p)
            if decide
                global notFail
                notFail=withdraw(stAgt,false,t,tCnt)
                stopCond=false
                #println(t)
                #println(tCnt)
                #println("withdrawal")

            end
            global notFail
            if !notFail
                break
            end
        end
        global notFail
        if stopCond | !notFail
            break
        end
    end
#println("Bank Failure?")
#println(!notFail)
end
# test functions
#tst=decision(agtList[1])
#println(tst)
#probList=Float64[]
#for agt in agtList
#    if agt.banked
#        push!(probList,mean(agtSimulate(agt)))
#    end
#end
#println(maximum(probList))
#println(minimum(probList))
#println(mean(probList))

# log model result
#println("Model Ends")
#println(theBank.vault)
modWrite(true)
